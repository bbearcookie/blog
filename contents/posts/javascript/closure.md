---
title: "클로저"
date: 2023-05-17
update: 2023-05-17
tags:
  - JavaScript
  - Closure
---

## [[Environment]]
자바스크립트 엔진이 어떤 함수 코드를 평가하면 함수 객체가 생성되게 된다.  
함수 객체의 내부 슬롯에는 `[[Environment]]` 가 존재하는데, 여기에는 함수 객체를 생성한 **당시에 실행중이었던 실행 컨텍스트의 렉시컬 환경**이 저장된다.  

즉, 어떤 함수 코드가 평가되는 시기에 실행중이던 실행 컨텍스트의 렉시컬 환경은 결국 함수의 입장에서는 자신을 감싸는 상위 스코프가 되기 때문에 **상위 스코프의 내용**의 참조가 `[[Environment]]` 에 저장된다는 것이다.  

이런 특징은 클로저를 이해하는데 도움이 된다.

## 클로저(Closure)란?
MDN 문서에 따르면 `클로저` 는 **함수와, 함수가 선언된 렉시컬 환경의 조합**이다.  

문자를 그대로 읽으면 난해하게 들리는데 조금 더 풀어서 이야기하면 **함수의 내부에 중첩되어 정의된 함수가 있고, 중첩 함수가 외부 함수의 렉시컬 환경에 존재하는 자원에 접근하면서, 외부 함수보다 오래동안 살아남는 그런 함수**다.

## 예시 코드
```js
function makeFunc() {
  let name = "Mozilla";

  function displayName() {
    alert(name);
  }

  return displayName;
}

let myFunc = makeFunc();
myFunc();
```

위 코드에서 `displayName()` 함수는 함수 내부에 선언된 중첩 함수이면서 외부 함수의 변수인 `name` 에 접근하고 있다. 그러므로 클로저이다.

### 의문점
분명히 `makeFunc()` 함수는 한번 호출된 이후에 내부 함수인 `displayName()` 을 반환하고 생명 주기를 다하여 실행 컨텍스트가 소멸된다.  
그런데 내부 함수인 `displayName()` 는 어떻게 이미 소멸한 실행 컨텍스트의 렉시컬 환경에 대해서 접근할 수 있는 것일까?

### 해답
이는 누군가가 참조하고 있는 렉시컬 환경같은 **메모리 공간을 가비지 콜렉터가 함부로 제거하지 않기 때문**이다.  
`makeFunc()` 실행 컨텍스트의 렉시컬 환경은 `displayName()` 이 참조하고 있기 때문에 `makeFunc()` 의 생명 주기가 다 해서 실행 컨텍스트가 제거된다고 해도 누군가에 의해서 참조되고 있는 렉시컬 환경은 아직 제거되지 않는다.

## 참고 자료
모던 JavaScript Deep Dive 23장 실행 컨텍스트, 24장 클로저  
[MDN 클로저](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures)  
